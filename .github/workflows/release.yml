name: release
on:
  workflow_run:
    workflows: [test]
    branches: [master]
    types: [completed]

# TODO check most recent commit?

jobs:
  release:
    runs-on: ubuntu-latest
    # need to manually check for success
    if: ${{
      github.event.workflow_run.conclusion == 'success'
      }}

    steps:
      - uses: actions/checkout@v2
        with:
          ref: ${{github.event.workflow_run.head_sha}}
          # need workflow access since we push branches
          # containing workflows
          token: ${{secrets.BOT_TOKEN}}
          # need all tags
          fetch-depth: 0

      - name: find-version
        run: |
          # rip version from lfs2.h
          LFS2_VERSION="$(grep -o '^#define LFS2_VERSION .*$' lfs2.h \
            | awk '{print $3}')"
          LFS2_VERSION_MAJOR="$((0xffff & ($LFS2_VERSION >> 16)))"
          LFS2_VERSION_MINOR="$((0xffff & ($LFS2_VERSION >>  0)))"

          # find a new patch version based on what we find in our tags
          LFS2_VERSION_PATCH="$( \
            ( git describe --tags --abbrev=0 \
                --match="v$LFS2_VERSION_MAJOR.$LFS2_VERSION_MINOR.*" \
              || echo 'v0.0.-1' ) \
            | awk -F '.' '{print $3+1}')"

          # found new version
          LFS2_VERSION="v$LFS2_VERSION_MAJOR`
            `.$LFS2_VERSION_MINOR`
            `.$LFS2_VERSION_PATCH"
          echo "LFS2_VERSION=$LFS2_VERSION"
          echo "LFS2_VERSION=$LFS2_VERSION" >> $GITHUB_ENV
          echo "LFS2_VERSION_MAJOR=$LFS2_VERSION_MAJOR" >> $GITHUB_ENV
          echo "LFS2_VERSION_MINOR=$LFS2_VERSION_MINOR" >> $GITHUB_ENV
          echo "LFS2_VERSION_PATCH=$LFS2_VERSION_PATCH" >> $GITHUB_ENV

      # try to find previous version?
      - name: find-prev-version
        continue-on-error: true
        run: |
          LFS2_PREV_VERSION="$(git describe --tags --abbrev=0 --match 'v*')"
          echo "LFS2_PREV_VERSION=$LFS2_PREV_VERSION"
          echo "LFS2_PREV_VERSION=$LFS2_PREV_VERSION" >> $GITHUB_ENV

      # create and update major branches (vN and vN-prefix)
      - name: build-major-branches
        run: |
          # create major branch
          git branch "v$LFS2_VERSION_MAJOR" HEAD

          # create major prefix branch
          git config user.name ${{secrets.BOT_USERNAME}}
          git config user.email ${{secrets.BOT_EMAIL}}
          git fetch "https://github.com/$GITHUB_REPOSITORY.git" \
            "v$LFS2_VERSION_MAJOR-prefix" || true
          ./scripts/prefix.py "lfs2$LFS2_VERSION_MAJOR"
          git branch "v$LFS2_VERSION_MAJOR-prefix" $( \
            git commit-tree $(git write-tree) \
              $(git rev-parse --verify -q FETCH_HEAD | sed -e 's/^/-p /') \
              -p HEAD \
              -m "Generated v$LFS2_VERSION_MAJOR prefixes")
          git reset --hard

          # push!
          git push --atomic origin \
            "v$LFS2_VERSION_MAJOR" \
            "v$LFS2_VERSION_MAJOR-prefix"

      # build release notes
      - name: build-release
        run: |
          # find changes since last release
          if [ ! -z "$LFS2_PREV_VERSION" ]
          then
            export CHANGES="$(git log --oneline $LFS2_PREV_VERSION.. \
              --grep='^Merge' --invert-grep)"
            printf "CHANGES\n%s\n\n" "$CHANGES"
          fi

          # create release and patch version tag (vN.N.N)
          # only draft if not a patch release
          curl -sS -H "authorization: token ${{secrets.BOT_TOKEN}}" \
            -X POST "$GITHUB_API_URL/repos/$GITHUB_REPOSITORY/releases" \
            -d "$(jq -n '{
              tag_name: env.LFS2_VERSION,
              name: env.LFS2_VERSION | sub("\\\\.0$"; ""),
              target_commitish: "${{github.event.workflow_run.head_sha}}",
              draft: env.LFS2_VERSION | endswith(".0"),
              body: (env.CHANGES // "")}' \
              | tee /dev/stderr)"

